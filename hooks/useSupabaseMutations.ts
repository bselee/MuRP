// @ts-nocheck
/**
 * Supabase Data Mutations
 * 
 * Helper functions for creating, updating, and deleting records in Supabase
 * These are used by App.tsx to replace the mock data mutations
 */

import { supabase } from '../lib/supabase/client';
import type {
  InventoryItem,
  Vendor,
  BillOfMaterials,
  PurchaseOrderStatus,
  BuildOrder,
  InternalRequisition,
  CreatePurchaseOrderInput,
  BomRevisionRequestOptions,
} from '../types';
import { emitEvent, emitStockLow } from '../services/eventBus';

// ============================================================================
// PURCHASE ORDERS
// ============================================================================

export async function createPurchaseOrder(po: CreatePurchaseOrderInput): Promise<{ success: boolean; error?: string }> {
  try {
    // Map UI status to database status
    const statusMap: Record<'Pending' | 'Submitted' | 'Fulfilled', string> = {
      'Pending': 'draft',
      'Submitted': 'sent',
      'Fulfilled': 'received'
    };

    // 1. Lookup vendor name
    const { data: vendor } = await supabase
      .from('vendors')
      .select('name')
      .eq('id', po.vendorId)
      .single();

    // Determine status and set appropriate timestamps
    const normalizedStatus = statusMap[po.status] || 'draft';
    const now = new Date().toISOString();

    // 2. Insert PO header with status-specific timestamps
    const { data: newPO, error: poError } = await supabase
      .from('purchase_orders')
      .insert({
        order_id: po.orderId || po.id,
        vendor_id: po.vendorId ?? null,
        supplier_name: vendor?.name || po.supplier || 'Unknown Vendor',
        status: normalizedStatus,
        order_date: po.orderDate || po.createdAt,
        expected_date: po.estimatedReceiveDate || po.expectedDate,
        internal_notes: po.vendorNotes || po.notes,
        requisition_ids: po.requisitionIds || [],
        source: 'manual',
        auto_generated: po.autoGenerated ?? false,
        tracking_number: po.trackingNumber || null,
        tracking_carrier: po.trackingCarrier || null,
        tracking_status: 'awaiting_confirmation',
        record_created: now,
        // Set sent_at if PO is being created in 'sent' status
        sent_at: normalizedStatus === 'sent' ? now : null,
        // Set committed_at if PO is being created in 'committed' status
        committed_at: normalizedStatus === 'committed' ? now : null,
      } as any)
      .select('id')
      .single();

    if (poError) throw poError;

    // 3. Insert line items
    if (newPO && po.items && po.items.length > 0) {
      const lineItems = po.items.map((item, idx) => ({
        po_id: newPO.id,
        inventory_sku: item.sku,
        item_name: item.name || item.description,
        quantity_ordered: item.quantity,
        unit_cost: item.unitCost ?? item.price ?? 0,
        line_number: idx + 1,
        line_status: 'pending',
      }));

      const { error: itemsError } = await supabase
        .from('purchase_order_items')
        .insert(lineItems);

      if (itemsError) throw itemsError;
    }

    // Emit po.created event for agent triggers
    emitEvent({
      type: 'po.created',
      data: {
        poId: newPO.id,
        orderId: po.orderId || po.id,
        vendorId: po.vendorId,
        vendorName: vendor?.name,
        itemCount: po.items?.length || 0,
        totalValue: po.items?.reduce((sum, item) => sum + (item.quantity * (item.unitCost ?? item.price ?? 0)), 0) || 0,
        autoGenerated: po.autoGenerated ?? false,
      },
      timestamp: new Date(),
      source: 'useSupabaseMutations',
    }).catch(err => console.warn('[createPurchaseOrder] Failed to emit event:', err));

    return { success: true };
  } catch (error) {
    console.error('[createPurchaseOrder] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create PO' };
  }
}

export async function logPoEmailTracking(
  poId: string,
  data: {
    gmailMessageId?: string | null;
    gmailThreadId?: string | null;
    vendorEmail?: string | null;
    metadata?: Record<string, any>;
    subject?: string | null;
    bodyPreview?: string | null;
    direction?: 'outbound' | 'inbound';
    communicationType?: string;
    senderEmail?: string | null;
    recipientEmail?: string | null;
    sentAt?: string | null;
    receivedAt?: string | null;
    stage?: number | null;
  },
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('po_email_tracking')
      .upsert(
        {
          po_id: poId,
          vendor_email: data.vendorEmail ?? null,
          gmail_message_id: data.gmailMessageId ?? null,
          gmail_thread_id: data.gmailThreadId ?? null,
          metadata: data.metadata ?? null,
          sent_at: new Date().toISOString(),
        },
        {
          onConflict: 'gmail_message_id',
        },
      );

    if (error) throw error;

    const communicationPayload = {
      po_id: poId,
      communication_type: data.communicationType ?? 'manual',
      direction: data.direction ?? 'outbound',
      stage: data.stage ?? null,
      gmail_message_id: data.gmailMessageId ?? null,
      gmail_thread_id: data.gmailThreadId ?? null,
      subject: data.subject ?? data.metadata?.subject ?? null,
      body_preview: data.bodyPreview ?? data.metadata?.bodyPreview ?? null,
      sender_email: data.senderEmail ?? data.metadata?.from ?? null,
      recipient_email: data.recipientEmail ?? data.vendorEmail ?? data.metadata?.to ?? null,
      sent_at:
        data.sentAt ??
        (data.direction === 'outbound' || !data.direction ? new Date().toISOString() : null),
      received_at:
        data.receivedAt ??
        (data.direction === 'inbound' ? new Date().toISOString() : null),
      metadata: data.metadata ?? null,
    };

    if (data.gmailMessageId) {
      const { error: commError } = await supabase
        .from('po_vendor_communications')
        .upsert(communicationPayload, { onConflict: 'gmail_message_id' });
      if (commError) throw commError;
    } else {
      const { error: commInsertError } = await supabase
        .from('po_vendor_communications')
        .insert(communicationPayload);
      if (commInsertError) throw commInsertError;
    }

    return { success: true };
  } catch (error) {
    console.error('[logPoEmailTracking] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to log PO email tracking metadata' };
  }
}

export async function updatePurchaseOrderStatus(
  id: string,
  status: PurchaseOrderStatus
): Promise<{ success: boolean; error?: string }> {
  try {
    // Map UI status to database status
    const statusMap: Record<string, string> = {
      'Pending': 'draft',
      'Submitted': 'sent',
      'Fulfilled': 'received',
      'Committed': 'committed',
      'draft': 'draft',
      'sent': 'sent',
      'received': 'received',
      'committed': 'committed',
    };

    const normalizedStatus = statusMap[status] || 'draft';

    // Get current status and vendor info before update
    const { data: poData } = await supabase
      .from('purchase_orders')
      .select('id, status, vendor_id')
      .or(`order_id.eq.${id},id.eq.${id}`)
      .maybeSingle();

    // Build update payload with status-specific timestamps
    const updatePayload: Record<string, any> = {
      status: normalizedStatus,
      record_last_updated: new Date().toISOString(),
    };

    // Set sent_at timestamp when transitioning to 'sent' status
    if (normalizedStatus === 'sent' && poData?.status !== 'sent') {
      updatePayload.sent_at = new Date().toISOString();
    }

    // Set committed_at timestamp when transitioning to 'committed' status
    if (normalizedStatus === 'committed' && poData?.status !== 'committed') {
      updatePayload.committed_at = new Date().toISOString();
    }

    const { error } = await supabase
      .from('purchase_orders')
      .update(updatePayload as any)
      .or(`order_id.eq.${id},id.eq.${id}`);

    if (error) throw error;

    // Emit status change events
    if (poData) {
      const previousStatus = poData.status;
      if (previousStatus !== normalizedStatus) {
        if (normalizedStatus === 'sent') {
          emitEvent({
            type: 'po.sent',
            data: { poId: poData.id, orderId: id, vendorId: poData.vendor_id, previousStatus },
            timestamp: new Date(),
            source: 'useSupabaseMutations',
          }).catch(err => console.warn('[updatePurchaseOrderStatus] Failed to emit po.sent:', err));
        } else if (normalizedStatus === 'received') {
          emitEvent({
            type: 'po.received',
            data: { poId: poData.id, orderId: id, vendorId: poData.vendor_id, previousStatus },
            timestamp: new Date(),
            source: 'useSupabaseMutations',
          }).catch(err => console.warn('[updatePurchaseOrderStatus] Failed to emit po.received:', err));
        }
      }
    }

    return { success: true };
  } catch (error) {
    console.error('[updatePurchaseOrderStatus] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update PO' };
  }
}

export async function appendPurchaseOrderNote(
  id: string,
  note: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const trimmedNote = note?.trim();
    if (!trimmedNote) {
      return { success: true };
    }

    const { data, error } = await supabase
      .from('purchase_orders')
      .select('id, internal_notes')
      .or(`order_id.eq.${id},id.eq.${id}`)
      .limit(1)
      .maybeSingle();

    if (error) throw error;
    if (!data?.id) {
      throw new Error('Purchase order not found');
    }

    const mergedNotes = data.internal_notes
      ? `${data.internal_notes}\n${trimmedNote}`
      : trimmedNote;

    const { error: updateError } = await supabase
      .from('purchase_orders')
      .update({
        internal_notes: mergedNotes,
        record_last_updated: new Date().toISOString(),
      })
      .eq('id', data.id);

    if (updateError) throw updateError;

    return { success: true };
  } catch (error) {
    console.error('[appendPurchaseOrderNote] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to append purchase order note' };
  }
}

// ============================================================================
// INVENTORY
// ============================================================================

export async function updateInventoryStock(
  sku: string,
  stockDelta: number,
  onOrderDelta: number = 0
): Promise<{ success: boolean; error?: string }> {
  try {
    // Get current item with reorder point
    const { data: item, error: fetchError } = await supabase
      .from('inventory_items')
      .select('stock, on_order, reorder_point')
      .eq('sku', sku)
      .single();

    if (fetchError) throw fetchError;
    if (!item) throw new Error(`Item ${sku} not found`);

    const currentStock = item.stock as number;
    const newStock = currentStock + stockDelta;
    const reorderPoint = (item.reorder_point as number) || 0;

    // Update with deltas
    const { error: updateError } = await supabase
      .from('inventory_items')
      .update({
        stock: newStock,
        on_order: (item.on_order as number) + onOrderDelta,
        updated_at: new Date().toISOString(),
      })
      .eq('sku', sku);

    if (updateError) throw updateError;

    // Emit stock events if crossing thresholds
    if (reorderPoint > 0) {
      // Stock fell below ROP
      if (currentStock >= reorderPoint && newStock < reorderPoint) {
        emitStockLow(sku, newStock, reorderPoint)
          .catch(err => console.warn('[updateInventoryStock] Failed to emit stock.low event:', err));
      }
      // Stock critically low (< 50% of ROP)
      if (newStock < reorderPoint * 0.5 && currentStock >= reorderPoint * 0.5) {
        emitEvent({
          type: 'stock.critical',
          data: { sku, currentStock: newStock, reorderPoint, percentOfROP: Math.round((newStock / reorderPoint) * 100) },
          timestamp: new Date(),
          source: 'useSupabaseMutations',
        }).catch(err => console.warn('[updateInventoryStock] Failed to emit stock.critical event:', err));
      }
      // Stockout
      if (newStock <= 0 && currentStock > 0) {
        emitEvent({
          type: 'stock.out',
          data: { sku, previousStock: currentStock },
          timestamp: new Date(),
          source: 'useSupabaseMutations',
        }).catch(err => console.warn('[updateInventoryStock] Failed to emit stock.out event:', err));
      }
    }

    return { success: true };
  } catch (error) {
    console.error('[updateInventoryStock] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update inventory' };
  }
}

export async function createInventoryItem(item: InventoryItem): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('inventory_items')
      .insert({
        sku: item.sku,
        name: item.name,
        category: item.category,
        stock: item.stock,
        on_order: item.onOrder,
        reorder_point: item.reorderPoint,
        vendor_id: item.vendorId,
        moq: item.moq,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createInventoryItem] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create inventory item' };
  }
}

export async function upsertInventoryItems(items: InventoryItem[]): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('inventory_items')
      .upsert(
        items.map(item => ({
          sku: item.sku,
          name: item.name,
          category: item.category,
          stock: item.stock,
          on_order: item.onOrder,
          reorder_point: item.reorderPoint,
          vendor_id: item.vendorId,
          moq: item.moq,
          updated_at: new Date().toISOString(),
        })),
        { onConflict: 'sku' }
      );

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[upsertInventoryItems] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to upsert inventory items' };
  }
}

// ============================================================================
// VENDORS
// ============================================================================

export async function upsertVendors(vendors: Vendor[]): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('vendors')
      .upsert(
        vendors.map(vendor => ({
          id: vendor.id,
          name: vendor.name,
          contact_emails: vendor.contactEmails,
          phone: vendor.phone,
          address: vendor.address,
          website: vendor.website,
          lead_time_days: vendor.leadTimeDays,
          updated_at: new Date().toISOString(),
        })),
        { onConflict: 'id' }
      );

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[upsertVendors] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to upsert vendors' };
  }
}

export async function createBuildOrder(order: BuildOrder): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('build_orders')
      .insert({
        id: order.id,
        finished_sku: order.finishedSku,
        name: order.name,
        quantity: order.quantity,
        status: order.status,
        created_at: order.createdAt,
        scheduled_date: order.scheduledDate,
        due_date: order.dueDate,
        calendar_event_id: order.calendarEventId,
        notes: order.notes,
        estimated_duration_hours: order.estimatedDurationHours,
        assigned_user_id: order.assignedUserId,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createBuildOrder] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create build order' };
  }
}

export async function updateBuildOrderStatus(
  id: string,
  status: 'Pending' | 'In Progress' | 'Completed'
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('build_orders')
      .update({
        status,
        completed_at: status === 'Completed' ? new Date().toISOString() : undefined,
        updated_at: new Date().toISOString(),
      })
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateBuildOrderStatus] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update build order' };
  }
}

export async function updateBuildOrder(buildOrder: BuildOrder): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('build_orders')
      .update({
        finished_sku: buildOrder.finishedSku,
        name: buildOrder.name,
        quantity: buildOrder.quantity,
        status: buildOrder.status,
        scheduled_date: buildOrder.scheduledDate,
        due_date: buildOrder.dueDate,
        calendar_event_id: buildOrder.calendarEventId,
        notes: buildOrder.notes,
        estimated_duration_hours: buildOrder.estimatedDurationHours,
        assigned_user_id: buildOrder.assignedUserId,
        updated_at: new Date().toISOString(),
      })
      .eq('id', buildOrder.id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateBuildOrder] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update build order' };
  }
}

// ============================================================================
// BOMS & REVISION CONTROL
// ============================================================================

const mapBomToDbPayload = (bom: BillOfMaterials) => ({
  finished_sku: bom.finishedSku,
  name: bom.name,
  components: bom.components as any,
  artwork: bom.artwork as any,
  packaging: bom.packaging as any,
  barcode: bom.barcode ?? null,
  description: bom.description ?? null,
  category: bom.category ?? null,
  yield_quantity: bom.yieldQuantity ?? null,
  potential_build_qty: bom.potentialBuildQty ?? null,
  average_cost: bom.averageCost ?? null,
  notes: bom.notes ?? null,
  data_source: bom.dataSource ?? 'manual',
  last_sync_at: bom.lastSyncAt ?? null,
  sync_status: bom.syncStatus ?? 'pending',
  primary_label_id: bom.primaryLabelId ?? null,
  primary_data_sheet_id: bom.primaryDataSheetId ?? null,
  compliance_status: bom.complianceStatus ?? null,
  total_state_registrations: bom.totalStateRegistrations ?? null,
  expiring_registrations_count: bom.expiringRegistrationsCount ?? null,
  compliance_last_checked: bom.complianceLastChecked ?? null,
  build_time_minutes: bom.buildTimeMinutes ?? null,
  labor_cost_per_hour: bom.laborCostPerHour ?? null,
});

export async function updateBOM(
  bom: BillOfMaterials,
  options: BomRevisionRequestOptions & { requestedBy?: string } = {}
): Promise<{ success: boolean; error?: string }> {
  try {
    const requestedBy = options.requestedBy ?? null;
    const reviewerId = options.reviewerId ?? null;
    const summary = options.summary ?? 'Manual update';
    const autoApprove = Boolean(options.autoApprove);
    const nextRevisionNumber = (bom.revisionNumber ?? 1) + 1;
    const revisionStatus = autoApprove ? 'approved' : 'pending';
    const now = new Date().toISOString();
    const dbPayload = mapBomToDbPayload(bom);
    const snapshotPayload = {
      ...dbPayload,
      revision_number: nextRevisionNumber,
      revision_status: revisionStatus,
      id: bom.id,
    };

    const { error: revisionError } = await supabase
      .from('bom_revisions')
      .insert({
        bom_id: bom.id,
        revision_number: nextRevisionNumber,
        status: revisionStatus,
        summary,
        change_summary: options.changeType ?? null,
        snapshot: snapshotPayload,
        created_by: requestedBy,
        reviewer_id: reviewerId,
        approved_by: autoApprove ? requestedBy : null,
        approved_at: autoApprove ? now : null,
      });

    if (revisionError) throw revisionError;

    const updatePayload: Record<string, any> = {
      ...dbPayload,
      revision_number: nextRevisionNumber,
      revision_status: revisionStatus,
      revision_summary: summary,
      revision_requested_by: requestedBy,
      revision_requested_at: now,
      revision_reviewer_id: reviewerId,
      revision_approved_by: autoApprove ? requestedBy : null,
      revision_approved_at: autoApprove ? now : null,
      updated_at: now,
    };

    if (autoApprove) {
      updatePayload.last_approved_at = now;
      updatePayload.last_approved_by = requestedBy;
    }

    const { error } = await supabase
      .from('boms')
      .update(updatePayload)
      .eq('id', bom.id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateBOM] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update BOM' };
  }
}

export async function approveBomRevision(
  bom: BillOfMaterials,
  approverId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const revisionNumber = bom.revisionNumber ?? 1;
    const now = new Date().toISOString();

    const { error: revisionError } = await supabase
      .from('bom_revisions')
      .update({
        status: 'approved',
        approved_by: approverId,
        approved_at: now,
      })
      .eq('bom_id', bom.id)
      .eq('revision_number', revisionNumber);

    if (revisionError) throw revisionError;

    const { error } = await supabase
      .from('boms')
      .update({
        revision_number: revisionNumber,
        revision_status: 'approved',
        revision_approved_by: approverId,
        revision_approved_at: now,
        last_approved_at: now,
        last_approved_by: approverId,
        updated_at: now,
      })
      .eq('id', bom.id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[approveBomRevision] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to approve BOM revision' };
  }
}

export async function revertBomToRevision(
  bom: BillOfMaterials,
  targetRevisionNumber: number,
  userId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const { data: targetRevision, error: fetchError } = await supabase
      .from('bom_revisions')
      .select('*')
      .eq('bom_id', bom.id)
      .eq('revision_number', targetRevisionNumber)
      .single();

    if (fetchError) throw fetchError;

    const snapshot = targetRevision?.snapshot;
    if (!snapshot) throw new Error('Revision snapshot unavailable');

    const now = new Date().toISOString();
    const nextRevisionNumber = (bom.revisionNumber ?? 1) + 1;

    const { error: insertError } = await supabase
      .from('bom_revisions')
      .insert({
        bom_id: bom.id,
        revision_number: nextRevisionNumber,
        status: 'approved',
        summary: `Reverted to REV ${targetRevisionNumber}`,
        snapshot,
        created_by: userId,
        reviewer_id: userId,
        approved_by: userId,
        approved_at: now,
        reverted_from_revision_id: targetRevision.id,
      });

    if (insertError) throw insertError;

    const updatePayload: Record<string, any> = {
      ...(snapshot as Record<string, any>),
      revision_number: nextRevisionNumber,
      revision_status: 'approved',
      revision_summary: `Reverted to REV ${targetRevisionNumber}`,
      revision_requested_by: userId,
      revision_requested_at: now,
      revision_reviewer_id: userId,
      revision_approved_by: userId,
      revision_approved_at: now,
      last_approved_at: now,
      last_approved_by: userId,
      updated_at: now,
    };

    const { error: updateError } = await supabase
      .from('boms')
      .update(updatePayload)
      .eq('id', bom.id);

    if (updateError) throw updateError;

    return { success: true };
  } catch (error) {
    console.error('[revertBomToRevision] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to revert BOM revision' };
  }
}

export async function createBOM(bom: BillOfMaterials): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('boms')
      .insert({
        id: bom.id,
        finished_sku: bom.finishedSku,
        name: bom.name,
        components: bom.components as any,
        artwork: bom.artwork as any,
        packaging: bom.packaging as any,
        barcode: bom.barcode,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createBOM] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create BOM' };
  }
}

// ============================================================================
// REQUISITIONS
// ============================================================================

export async function updateRequisitionStatus(
  id: string,
  status: InternalRequisition['status'],
  additionalFields?: Record<string, any>
): Promise<{ success: boolean; error?: string }> {
  try {
    const payload: Record<string, any> = { status, updated_at: new Date().toISOString() };
    if (additionalFields) {
      Object.assign(payload, additionalFields);
    }
    const { error } = await supabase
      .from('requisitions')
      .update(payload)
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateRequisitionStatus] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update requisition' };
  }
}

export async function updateMultipleRequisitions(
  ids: string[],
  status: InternalRequisition['status'],
  additionalFields?: Record<string, any>
): Promise<{ success: boolean; error?: string }> {
  try {
    const payload: Record<string, any> = { status, updated_at: new Date().toISOString() };
    if (additionalFields) {
      Object.assign(payload, additionalFields);
    }
    const { error } = await supabase
      .from('requisitions')
      .update(payload)
      .in('id', ids);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateMultipleRequisitions] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update requisitions' };
  }
}

export async function createRequisition(req: InternalRequisition): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('requisitions')
      .insert({
        id: req.id,
        requester_id: req.requesterId ?? null,
        department: req.department,
        status: req.status,
        created_at: req.createdAt,
        source: req.source,
        items: req.items as any,
        notes: req.notes ?? req.context ?? null,
        request_type: req.requestType ?? 'consumable',
        priority: req.priority ?? 'medium',
        need_by_date: req.needByDate ?? null,
        alert_only: req.alertOnly ?? false,
        auto_po: req.autoPo ?? false,
        notify_requester: req.notifyRequester ?? true,
        context: req.context ?? null,
        metadata: req.metadata ?? {},
        manager_approved_by: req.managerApprovedBy ?? null,
        manager_approved_at: req.managerApprovedAt ?? null,
        ops_approval_required: req.opsApprovalRequired ?? false,
        ops_approved_by: req.opsApprovedBy ?? null,
        ops_approved_at: req.opsApprovedAt ?? null,
        forwarded_to_purchasing_at: req.forwardedToPurchasingAt ?? null,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createRequisition] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create requisition' };
  }
}

// ============================================================================
// BATCH OPERATIONS
// ============================================================================

export async function batchUpdateInventory(
  updates: Array<{ sku: string; stockDelta: number; onOrderDelta?: number }>
): Promise<{ success: boolean; error?: string }> {
  try {
    // Execute all updates
    const results = await Promise.all(
      updates.map(update => updateInventoryStock(update.sku, update.stockDelta, update.onOrderDelta || 0))
    );

    // Check if any failed
    const failed = results.filter(r => !r.success);
    if (failed.length > 0) {
      throw new Error(`${failed.length} inventory updates failed`);
    }

    return { success: true };
  } catch (error) {
    console.error('[batchUpdateInventory] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to batch update inventory' };
  }
}

// ============================================================================
// ARTWORK APPROVAL
// ============================================================================

export async function approveArtworkForPrintReady(
  bomId: string,
  artworkId: string,
  approverId: string,
  approvalNotes?: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const now = new Date().toISOString();

    // Update artwork record in BOM
    const { data: bom, error: fetchError } = await supabase
      .from('boms')
      .select('artwork')
      .eq('id', bomId)
      .single();

    if (fetchError) throw fetchError;

    const updatedArtwork = (bom?.artwork ?? []).map((art: any) => {
      if (art.id === artworkId) {
        return {
          ...art,
          status: 'approved',
          approvedBy: approverId,
          approvedDate: now,
          printReady: true,
          approvalNotes,
        };
      }
      return art;
    });

    const { error: updateError } = await supabase
      .from('boms')
      .update({ artwork: updatedArtwork, updated_at: now })
      .eq('id', bomId);

    if (updateError) throw updateError;

    return { success: true };
  } catch (error) {
    console.error('[approveArtworkForPrintReady] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to approve artwork',
    };
  }
}

export async function rejectArtworkApproval(
  bomId: string,
  artworkId: string,
  rejectionReason: string,
  rejectedBy: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const now = new Date().toISOString();

    const { data: bom, error: fetchError } = await supabase
      .from('boms')
      .select('artwork')
      .eq('id', bomId)
      .single();

    if (fetchError) throw fetchError;

    const updatedArtwork = (bom?.artwork ?? []).map((art: any) => {
      if (art.id === artworkId) {
        return {
          ...art,
          status: 'draft',
          printReady: false,
          rejectionReason,
          rejectedBy,
          rejectedAt: now,
        };
      }
      return art;
    });

    const { error: updateError } = await supabase
      .from('boms')
      .update({ artwork: updatedArtwork, updated_at: now })
      .eq('id', bomId);

    if (updateError) throw updateError;

    return { success: true };
  } catch (error) {
    console.error('[rejectArtworkApproval] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to reject artwork',
    };
  }
}

export async function receivePurchaseOrder({
  poId,
  receivedItems,
  receivedBy,
  notes,
}: {
  poId: string;
  receivedItems: Array<{
    itemId: string;
    receivedQuantity: number;
    backorderQuantity?: number;
    condition?: 'good' | 'damaged' | 'partial';
    notes?: string;
  }>;
  receivedBy: string;
  notes?: string;
}) {
  try {
    const now = new Date().toISOString();

    // First, get the current PO to validate and update
    const { data: po, error: fetchError } = await supabase
      .from('purchase_orders')
      .select('*')
      .eq('id', poId)
      .single();

    if (fetchError || !po) {
      throw new Error(`Purchase order not found: ${fetchError?.message || 'Unknown error'}`);
    }

    // Calculate totals for received items
    const totalReceived = receivedItems.reduce((sum, item) => sum + item.receivedQuantity, 0);
    const totalBackordered = receivedItems.reduce((sum, item) => sum + (item.backorderQuantity || 0), 0);

    // Update inventory for each received item
    for (const item of receivedItems) {
      if (item.receivedQuantity > 0) {
        // Get current inventory
        const { data: inventoryItem, error: inventoryError } = await supabase
          .from('inventory')
          .select('*')
          .eq('id', item.itemId)
          .single();

        if (inventoryError) {
          console.warn(`Could not find inventory item ${item.itemId}:`, inventoryError);
          continue;
        }

        // Update inventory quantity
        const newQuantity = (inventoryItem.quantity || 0) + item.receivedQuantity;
        const { error: updateInventoryError } = await supabase
          .from('inventory')
          .update({
            quantity: newQuantity,
            last_updated: now,
            updated_by: receivedBy,
          })
          .eq('id', item.itemId);

        if (updateInventoryError) {
          console.error(`Failed to update inventory for item ${item.itemId}:`, updateInventoryError);
        }
      }
    }

    // Update PO status and tracking
    const newStatus = totalBackordered > 0 ? 'partially_received' : 'received';
    const { error: updatePoError } = await supabase
      .from('purchase_orders')
      .update({
        status: newStatus,
        received_at: now,
        received_by: receivedBy,
        received_quantity: totalReceived,
        backorder_quantity: totalBackordered,
        updated_at: now,
      })
      .eq('id', poId);

    if (updatePoError) throw updatePoError;

    // Add tracking entry
    const { error: trackingError } = await supabase
      .from('po_tracking')
      .insert({
        po_id: poId,
        event_type: 'received',
        event_data: {
          receivedItems,
          totalReceived,
          totalBackordered,
          receivedBy,
          notes,
        },
        created_by: receivedBy,
        created_at: now,
      });

    if (trackingError) {
      console.error('Failed to add tracking entry:', trackingError);
    }

    // Add note if provided
    if (notes) {
      await appendPurchaseOrderNote({
        poId,
        note: `Received ${totalReceived} items${totalBackordered > 0 ? ` (${totalBackordered} backordered)` : ''}. ${notes}`,
        createdBy: receivedBy,
      });
    }

    return { success: true, totalReceived, totalBackordered };
  } catch (error) {
    console.error('[receivePurchaseOrder] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to receive purchase order',
    };
  }
}
