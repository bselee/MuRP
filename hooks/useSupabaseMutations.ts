// @ts-nocheck
/**
 * Supabase Data Mutations
 * 
 * Helper functions for creating, updating, and deleting records in Supabase
 * These are used by App.tsx to replace the mock data mutations
 */

import { supabase } from '../lib/supabase/client';
import type {
  InventoryItem,
  Vendor,
  BillOfMaterials,
  PurchaseOrderStatus,
  BuildOrder,
  InternalRequisition,
  CreatePurchaseOrderInput,
  BomRevisionRequestOptions,
} from '../types';

// ============================================================================
// PURCHASE ORDERS
// ============================================================================

export async function createPurchaseOrder(po: CreatePurchaseOrderInput): Promise<{ success: boolean; error?: string }> {
  try {
    // Map UI status to database status
    const statusMap: Record<'Pending' | 'Submitted' | 'Fulfilled', string> = {
      'Pending': 'draft',
      'Submitted': 'sent',
      'Fulfilled': 'received'
    };

    // 1. Lookup vendor name
    const { data: vendor } = await supabase
      .from('vendors')
      .select('name')
      .eq('id', po.vendorId)
      .single();

    // 2. Insert PO header
    const { data: newPO, error: poError } = await supabase
      .from('purchase_orders')
      .insert({
        order_id: po.orderId || po.id,
        vendor_id: po.vendorId ?? null,
        supplier_name: vendor?.name || po.supplier || 'Unknown Vendor',
        status: statusMap[po.status] || 'draft',
        order_date: po.orderDate || po.createdAt,
        expected_date: po.estimatedReceiveDate || po.expectedDate,
        internal_notes: po.vendorNotes || po.notes,
        requisition_ids: po.requisitionIds || [],
        source: 'manual',
        auto_generated: po.autoGenerated ?? false,
        tracking_number: po.trackingNumber || null,
        tracking_carrier: po.trackingCarrier || null,
        tracking_status: 'awaiting_confirmation',
        record_created: new Date().toISOString(),
      } as any)
      .select('id')
      .single();

    if (poError) throw poError;

    // 3. Insert line items
    if (newPO && po.items && po.items.length > 0) {
      const lineItems = po.items.map((item, idx) => ({
        po_id: newPO.id,
        inventory_sku: item.sku,
        item_name: item.name || item.description,
        quantity_ordered: item.quantity,
        unit_cost: item.unitCost ?? item.price ?? 0,
        line_number: idx + 1,
        line_status: 'pending',
      }));

      const { error: itemsError } = await supabase
        .from('purchase_order_items')
        .insert(lineItems);

      if (itemsError) throw itemsError;
    }
    return { success: true };
  } catch (error) {
    console.error('[createPurchaseOrder] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create PO' };
  }
}

export async function logPoEmailTracking(
  poId: string,
  data: {
    gmailMessageId?: string | null;
    gmailThreadId?: string | null;
    vendorEmail?: string | null;
    metadata?: Record<string, any>;
    subject?: string | null;
    bodyPreview?: string | null;
    direction?: 'outbound' | 'inbound';
    communicationType?: string;
    senderEmail?: string | null;
    recipientEmail?: string | null;
    sentAt?: string | null;
    receivedAt?: string | null;
    stage?: number | null;
  },
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('po_email_tracking')
      .upsert(
        {
          po_id: poId,
          vendor_email: data.vendorEmail ?? null,
          gmail_message_id: data.gmailMessageId ?? null,
          gmail_thread_id: data.gmailThreadId ?? null,
          metadata: data.metadata ?? null,
          sent_at: new Date().toISOString(),
        },
        {
          onConflict: 'gmail_message_id',
        },
      );

    if (error) throw error;

    const communicationPayload = {
      po_id: poId,
      communication_type: data.communicationType ?? 'manual',
      direction: data.direction ?? 'outbound',
      stage: data.stage ?? null,
      gmail_message_id: data.gmailMessageId ?? null,
      gmail_thread_id: data.gmailThreadId ?? null,
      subject: data.subject ?? data.metadata?.subject ?? null,
      body_preview: data.bodyPreview ?? data.metadata?.bodyPreview ?? null,
      sender_email: data.senderEmail ?? data.metadata?.from ?? null,
      recipient_email: data.recipientEmail ?? data.vendorEmail ?? data.metadata?.to ?? null,
      sent_at:
        data.sentAt ??
        (data.direction === 'outbound' || !data.direction ? new Date().toISOString() : null),
      received_at:
        data.receivedAt ??
        (data.direction === 'inbound' ? new Date().toISOString() : null),
      metadata: data.metadata ?? null,
    };

    if (data.gmailMessageId) {
      const { error: commError } = await supabase
        .from('po_vendor_communications')
        .upsert(communicationPayload, { onConflict: 'gmail_message_id' });
      if (commError) throw commError;
    } else {
      const { error: commInsertError } = await supabase
        .from('po_vendor_communications')
        .insert(communicationPayload);
      if (commInsertError) throw commInsertError;
    }

    return { success: true };
  } catch (error) {
    console.error('[logPoEmailTracking] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to log PO email tracking metadata' };
  }
}

export async function updatePurchaseOrderStatus(
  id: string,
  status: PurchaseOrderStatus
): Promise<{ success: boolean; error?: string }> {
  try {
    // Map UI status to database status
    const statusMap: Record<'Pending' | 'Submitted' | 'Fulfilled', string> = {
      'Pending': 'draft',
      'Submitted': 'sent',
      'Fulfilled': 'received'
    };

    const { error } = await supabase
      .from('purchase_orders')
      .update({
        status: statusMap[status] || 'draft',
        record_last_updated: new Date().toISOString()
      } as any)
      .or(`order_id.eq.${id},id.eq.${id}`);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updatePurchaseOrderStatus] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update PO' };
  }
}

// ============================================================================
// INVENTORY
// ============================================================================

export async function updateInventoryStock(
  sku: string,
  stockDelta: number,
  onOrderDelta: number = 0
): Promise<{ success: boolean; error?: string }> {
  try {
    // Get current item
    const { data: item, error: fetchError } = await supabase
      .from('inventory_items')
      .select('stock, on_order')
      .eq('sku', sku)
      .single();

    if (fetchError) throw fetchError;
    if (!item) throw new Error(`Item ${sku} not found`);

    // Update with deltas
    const { error: updateError } = await supabase
      .from('inventory_items')
      .update({
        stock: (item.stock as number) + stockDelta,
        on_order: (item.on_order as number) + onOrderDelta,
        updated_at: new Date().toISOString(),
      })
      .eq('sku', sku);

    if (updateError) throw updateError;
    return { success: true };
  } catch (error) {
    console.error('[updateInventoryStock] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update inventory' };
  }
}

export async function createInventoryItem(item: InventoryItem): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('inventory_items')
      .insert({
        sku: item.sku,
        name: item.name,
        category: item.category,
        stock: item.stock,
        on_order: item.onOrder,
        reorder_point: item.reorderPoint,
        vendor_id: item.vendorId,
        moq: item.moq,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createInventoryItem] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create inventory item' };
  }
}

// ============================================================================
// BUILD ORDERS
// ============================================================================

export async function createBuildOrder(order: BuildOrder): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('build_orders')
      .insert({
        id: order.id,
        finished_sku: order.finishedSku,
        name: order.name,
        quantity: order.quantity,
        status: order.status,
        created_at: order.createdAt,
        scheduled_date: order.scheduledDate,
        due_date: order.dueDate,
        calendar_event_id: order.calendarEventId,
        notes: order.notes,
        estimated_duration_hours: order.estimatedDurationHours,
        assigned_user_id: order.assignedUserId,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createBuildOrder] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create build order' };
  }
}

export async function updateBuildOrderStatus(
  id: string,
  status: 'Pending' | 'In Progress' | 'Completed'
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('build_orders')
      .update({
        status,
        completed_at: status === 'Completed' ? new Date().toISOString() : undefined,
        updated_at: new Date().toISOString(),
      })
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateBuildOrderStatus] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update build order' };
  }
}

export async function updateBuildOrder(buildOrder: BuildOrder): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('build_orders')
      .update({
        finished_sku: buildOrder.finishedSku,
        name: buildOrder.name,
        quantity: buildOrder.quantity,
        status: buildOrder.status,
        scheduled_date: buildOrder.scheduledDate,
        due_date: buildOrder.dueDate,
        calendar_event_id: buildOrder.calendarEventId,
        notes: buildOrder.notes,
        estimated_duration_hours: buildOrder.estimatedDurationHours,
        assigned_user_id: buildOrder.assignedUserId,
        updated_at: new Date().toISOString(),
      })
      .eq('id', buildOrder.id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateBuildOrder] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update build order' };
  }
}

// ============================================================================
// BOMS & REVISION CONTROL
// ============================================================================

const mapBomToDbPayload = (bom: BillOfMaterials) => ({
  finished_sku: bom.finishedSku,
  name: bom.name,
  components: bom.components as any,
  artwork: bom.artwork as any,
  packaging: bom.packaging as any,
  barcode: bom.barcode ?? null,
  description: bom.description ?? null,
  category: bom.category ?? null,
  yield_quantity: bom.yieldQuantity ?? null,
  potential_build_qty: bom.potentialBuildQty ?? null,
  average_cost: bom.averageCost ?? null,
  notes: bom.notes ?? null,
  data_source: bom.dataSource ?? 'manual',
  last_sync_at: bom.lastSyncAt ?? null,
  sync_status: bom.syncStatus ?? 'pending',
  primary_label_id: bom.primaryLabelId ?? null,
  primary_data_sheet_id: bom.primaryDataSheetId ?? null,
  compliance_status: bom.complianceStatus ?? null,
  total_state_registrations: bom.totalStateRegistrations ?? null,
  expiring_registrations_count: bom.expiringRegistrationsCount ?? null,
  compliance_last_checked: bom.complianceLastChecked ?? null,
  build_time_minutes: bom.buildTimeMinutes ?? null,
  labor_cost_per_hour: bom.laborCostPerHour ?? null,
});

export async function updateBOM(
  bom: BillOfMaterials,
  options: BomRevisionRequestOptions & { requestedBy?: string } = {}
): Promise<{ success: boolean; error?: string }> {
  try {
    const requestedBy = options.requestedBy ?? null;
    const reviewerId = options.reviewerId ?? null;
    const summary = options.summary ?? 'Manual update';
    const autoApprove = Boolean(options.autoApprove);
    const nextRevisionNumber = (bom.revisionNumber ?? 1) + 1;
    const revisionStatus = autoApprove ? 'approved' : 'pending';
    const now = new Date().toISOString();
    const dbPayload = mapBomToDbPayload(bom);
    const snapshotPayload = {
      ...dbPayload,
      revision_number: nextRevisionNumber,
      revision_status: revisionStatus,
      id: bom.id,
    };

    const { error: revisionError } = await supabase
      .from('bom_revisions')
      .insert({
        bom_id: bom.id,
        revision_number: nextRevisionNumber,
        status: revisionStatus,
        summary,
        change_summary: options.changeType ?? null,
        snapshot: snapshotPayload,
        created_by: requestedBy,
        reviewer_id: reviewerId,
        approved_by: autoApprove ? requestedBy : null,
        approved_at: autoApprove ? now : null,
      });

    if (revisionError) throw revisionError;

    const updatePayload: Record<string, any> = {
      ...dbPayload,
      revision_number: nextRevisionNumber,
      revision_status: revisionStatus,
      revision_summary: summary,
      revision_requested_by: requestedBy,
      revision_requested_at: now,
      revision_reviewer_id: reviewerId,
      revision_approved_by: autoApprove ? requestedBy : null,
      revision_approved_at: autoApprove ? now : null,
      updated_at: now,
    };

    if (autoApprove) {
      updatePayload.last_approved_at = now;
      updatePayload.last_approved_by = requestedBy;
    }

    const { error } = await supabase
      .from('boms')
      .update(updatePayload)
      .eq('id', bom.id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateBOM] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update BOM' };
  }
}

export async function approveBomRevision(
  bom: BillOfMaterials,
  approverId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const revisionNumber = bom.revisionNumber ?? 1;
    const now = new Date().toISOString();

    const { error: revisionError } = await supabase
      .from('bom_revisions')
      .update({
        status: 'approved',
        approved_by: approverId,
        approved_at: now,
      })
      .eq('bom_id', bom.id)
      .eq('revision_number', revisionNumber);

    if (revisionError) throw revisionError;

    const { error } = await supabase
      .from('boms')
      .update({
        revision_number: revisionNumber,
        revision_status: 'approved',
        revision_approved_by: approverId,
        revision_approved_at: now,
        last_approved_at: now,
        last_approved_by: approverId,
        updated_at: now,
      })
      .eq('id', bom.id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[approveBomRevision] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to approve BOM revision' };
  }
}

export async function revertBomToRevision(
  bom: BillOfMaterials,
  targetRevisionNumber: number,
  userId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const { data: targetRevision, error: fetchError } = await supabase
      .from('bom_revisions')
      .select('*')
      .eq('bom_id', bom.id)
      .eq('revision_number', targetRevisionNumber)
      .single();

    if (fetchError) throw fetchError;

    const snapshot = targetRevision?.snapshot;
    if (!snapshot) throw new Error('Revision snapshot unavailable');

    const now = new Date().toISOString();
    const nextRevisionNumber = (bom.revisionNumber ?? 1) + 1;

    const { error: insertError } = await supabase
      .from('bom_revisions')
      .insert({
        bom_id: bom.id,
        revision_number: nextRevisionNumber,
        status: 'approved',
        summary: `Reverted to REV ${targetRevisionNumber}`,
        snapshot,
        created_by: userId,
        reviewer_id: userId,
        approved_by: userId,
        approved_at: now,
        reverted_from_revision_id: targetRevision.id,
      });

    if (insertError) throw insertError;

    const updatePayload: Record<string, any> = {
      ...(snapshot as Record<string, any>),
      revision_number: nextRevisionNumber,
      revision_status: 'approved',
      revision_summary: `Reverted to REV ${targetRevisionNumber}`,
      revision_requested_by: userId,
      revision_requested_at: now,
      revision_reviewer_id: userId,
      revision_approved_by: userId,
      revision_approved_at: now,
      last_approved_at: now,
      last_approved_by: userId,
      updated_at: now,
    };

    const { error: updateError } = await supabase
      .from('boms')
      .update(updatePayload)
      .eq('id', bom.id);

    if (updateError) throw updateError;

    return { success: true };
  } catch (error) {
    console.error('[revertBomToRevision] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to revert BOM revision' };
  }
}

export async function createBOM(bom: BillOfMaterials): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('boms')
      .insert({
        id: bom.id,
        finished_sku: bom.finishedSku,
        name: bom.name,
        components: bom.components as any,
        artwork: bom.artwork as any,
        packaging: bom.packaging as any,
        barcode: bom.barcode,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createBOM] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create BOM' };
  }
}

// ============================================================================
// REQUISITIONS
// ============================================================================

export async function updateRequisitionStatus(
  id: string,
  status: InternalRequisition['status'],
  additionalFields?: Record<string, any>
): Promise<{ success: boolean; error?: string }> {
  try {
    const payload: Record<string, any> = { status, updated_at: new Date().toISOString() };
    if (additionalFields) {
      Object.assign(payload, additionalFields);
    }
    const { error } = await supabase
      .from('requisitions')
      .update(payload)
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateRequisitionStatus] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update requisition' };
  }
}

export async function updateMultipleRequisitions(
  ids: string[],
  status: InternalRequisition['status'],
  additionalFields?: Record<string, any>
): Promise<{ success: boolean; error?: string }> {
  try {
    const payload: Record<string, any> = { status, updated_at: new Date().toISOString() };
    if (additionalFields) {
      Object.assign(payload, additionalFields);
    }
    const { error } = await supabase
      .from('requisitions')
      .update(payload)
      .in('id', ids);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[updateMultipleRequisitions] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to update requisitions' };
  }
}

export async function createRequisition(req: InternalRequisition): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from('requisitions')
      .insert({
        id: req.id,
        requester_id: req.requesterId ?? null,
        department: req.department,
        status: req.status,
        created_at: req.createdAt,
        source: req.source,
        items: req.items as any,
        notes: req.notes ?? req.context ?? null,
        request_type: req.requestType ?? 'consumable',
        priority: req.priority ?? 'medium',
        need_by_date: req.needByDate ?? null,
        alert_only: req.alertOnly ?? false,
        auto_po: req.autoPo ?? false,
        notify_requester: req.notifyRequester ?? true,
        context: req.context ?? null,
        metadata: req.metadata ?? {},
        manager_approved_by: req.managerApprovedBy ?? null,
        manager_approved_at: req.managerApprovedAt ?? null,
        ops_approval_required: req.opsApprovalRequired ?? false,
        ops_approved_by: req.opsApprovedBy ?? null,
        ops_approved_at: req.opsApprovedAt ?? null,
        forwarded_to_purchasing_at: req.forwardedToPurchasingAt ?? null,
      });

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('[createRequisition] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to create requisition' };
  }
}

// ============================================================================
// BATCH OPERATIONS
// ============================================================================

export async function batchUpdateInventory(
  updates: Array<{ sku: string; stockDelta: number; onOrderDelta?: number }>
): Promise<{ success: boolean; error?: string }> {
  try {
    // Execute all updates
    const results = await Promise.all(
      updates.map(update => updateInventoryStock(update.sku, update.stockDelta, update.onOrderDelta || 0))
    );

    // Check if any failed
    const failed = results.filter(r => !r.success);
    if (failed.length > 0) {
      throw new Error(`${failed.length} inventory updates failed`);
    }

    return { success: true };
  } catch (error) {
    console.error('[batchUpdateInventory] Error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Failed to batch update inventory' };
  }
}
